// Code generated by ent, DO NOT EDIT.

package user

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the user type in the database.
	Label = "user"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldIndex holds the string denoting the index field in the database.
	FieldIndex = "index"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldBio holds the string denoting the bio field in the database.
	FieldBio = "bio"
	// FieldStreakCount holds the string denoting the streak_count field in the database.
	FieldStreakCount = "streak_count"
	// FieldIconImageKey holds the string denoting the icon_image_key field in the database.
	FieldIconImageKey = "icon_image_key"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// EdgePosts holds the string denoting the posts edge name in mutations.
	EdgePosts = "posts"
	// EdgeComments holds the string denoting the comments edge name in mutations.
	EdgeComments = "comments"
	// EdgeLikes holds the string denoting the likes edge name in mutations.
	EdgeLikes = "likes"
	// EdgePets holds the string denoting the pets edge name in mutations.
	EdgePets = "pets"
	// EdgeFollowing holds the string denoting the following edge name in mutations.
	EdgeFollowing = "following"
	// EdgeFollowers holds the string denoting the followers edge name in mutations.
	EdgeFollowers = "followers"
	// EdgeBlocking holds the string denoting the blocking edge name in mutations.
	EdgeBlocking = "blocking"
	// EdgeBlockedBy holds the string denoting the blocked_by edge name in mutations.
	EdgeBlockedBy = "blocked_by"
	// EdgeDailyTasks holds the string denoting the daily_tasks edge name in mutations.
	EdgeDailyTasks = "daily_tasks"
	// EdgeDeviceTokens holds the string denoting the device_tokens edge name in mutations.
	EdgeDeviceTokens = "device_tokens"
	// Table holds the table name of the user in the database.
	Table = "users"
	// PostsTable is the table that holds the posts relation/edge.
	PostsTable = "posts"
	// PostsInverseTable is the table name for the Post entity.
	// It exists in this package in order to avoid circular dependency with the "post" package.
	PostsInverseTable = "posts"
	// PostsColumn is the table column denoting the posts relation/edge.
	PostsColumn = "user_posts"
	// CommentsTable is the table that holds the comments relation/edge.
	CommentsTable = "comments"
	// CommentsInverseTable is the table name for the Comment entity.
	// It exists in this package in order to avoid circular dependency with the "comment" package.
	CommentsInverseTable = "comments"
	// CommentsColumn is the table column denoting the comments relation/edge.
	CommentsColumn = "user_comments"
	// LikesTable is the table that holds the likes relation/edge.
	LikesTable = "likes"
	// LikesInverseTable is the table name for the Like entity.
	// It exists in this package in order to avoid circular dependency with the "like" package.
	LikesInverseTable = "likes"
	// LikesColumn is the table column denoting the likes relation/edge.
	LikesColumn = "user_likes"
	// PetsTable is the table that holds the pets relation/edge.
	PetsTable = "pets"
	// PetsInverseTable is the table name for the Pet entity.
	// It exists in this package in order to avoid circular dependency with the "pet" package.
	PetsInverseTable = "pets"
	// PetsColumn is the table column denoting the pets relation/edge.
	PetsColumn = "user_pets"
	// FollowingTable is the table that holds the following relation/edge.
	FollowingTable = "follow_relations"
	// FollowingInverseTable is the table name for the FollowRelation entity.
	// It exists in this package in order to avoid circular dependency with the "followrelation" package.
	FollowingInverseTable = "follow_relations"
	// FollowingColumn is the table column denoting the following relation/edge.
	FollowingColumn = "user_following"
	// FollowersTable is the table that holds the followers relation/edge.
	FollowersTable = "follow_relations"
	// FollowersInverseTable is the table name for the FollowRelation entity.
	// It exists in this package in order to avoid circular dependency with the "followrelation" package.
	FollowersInverseTable = "follow_relations"
	// FollowersColumn is the table column denoting the followers relation/edge.
	FollowersColumn = "user_followers"
	// BlockingTable is the table that holds the blocking relation/edge.
	BlockingTable = "block_relations"
	// BlockingInverseTable is the table name for the BlockRelation entity.
	// It exists in this package in order to avoid circular dependency with the "blockrelation" package.
	BlockingInverseTable = "block_relations"
	// BlockingColumn is the table column denoting the blocking relation/edge.
	BlockingColumn = "user_blocking"
	// BlockedByTable is the table that holds the blocked_by relation/edge.
	BlockedByTable = "block_relations"
	// BlockedByInverseTable is the table name for the BlockRelation entity.
	// It exists in this package in order to avoid circular dependency with the "blockrelation" package.
	BlockedByInverseTable = "block_relations"
	// BlockedByColumn is the table column denoting the blocked_by relation/edge.
	BlockedByColumn = "user_blocked_by"
	// DailyTasksTable is the table that holds the daily_tasks relation/edge.
	DailyTasksTable = "daily_tasks"
	// DailyTasksInverseTable is the table name for the DailyTask entity.
	// It exists in this package in order to avoid circular dependency with the "dailytask" package.
	DailyTasksInverseTable = "daily_tasks"
	// DailyTasksColumn is the table column denoting the daily_tasks relation/edge.
	DailyTasksColumn = "user_daily_tasks"
	// DeviceTokensTable is the table that holds the device_tokens relation/edge.
	DeviceTokensTable = "device_tokens"
	// DeviceTokensInverseTable is the table name for the DeviceToken entity.
	// It exists in this package in order to avoid circular dependency with the "devicetoken" package.
	DeviceTokensInverseTable = "device_tokens"
	// DeviceTokensColumn is the table column denoting the device_tokens relation/edge.
	DeviceTokensColumn = "user_id"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
	FieldID,
	FieldIndex,
	FieldEmail,
	FieldName,
	FieldBio,
	FieldStreakCount,
	FieldIconImageKey,
	FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// EmailValidator is a validator for the "email" field. It is called by the builders before save.
	EmailValidator func(string) error
	// NameValidator is a validator for the "name" field. It is called by the builders before save.
	NameValidator func(string) error
	// DefaultBio holds the default value on creation for the "bio" field.
	DefaultBio string
	// DefaultStreakCount holds the default value on creation for the "streak_count" field.
	DefaultStreakCount uint32
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByIndex orders the results by the index field.
func ByIndex(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIndex, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByBio orders the results by the bio field.
func ByBio(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBio, opts...).ToFunc()
}

// ByStreakCount orders the results by the streak_count field.
func ByStreakCount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStreakCount, opts...).ToFunc()
}

// ByIconImageKey orders the results by the icon_image_key field.
func ByIconImageKey(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIconImageKey, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByPostsCount orders the results by posts count.
func ByPostsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPostsStep(), opts...)
	}
}

// ByPosts orders the results by posts terms.
func ByPosts(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPostsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCommentsCount orders the results by comments count.
func ByCommentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCommentsStep(), opts...)
	}
}

// ByComments orders the results by comments terms.
func ByComments(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCommentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByLikesCount orders the results by likes count.
func ByLikesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newLikesStep(), opts...)
	}
}

// ByLikes orders the results by likes terms.
func ByLikes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLikesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPetsCount orders the results by pets count.
func ByPetsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPetsStep(), opts...)
	}
}

// ByPets orders the results by pets terms.
func ByPets(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPetsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFollowingCount orders the results by following count.
func ByFollowingCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFollowingStep(), opts...)
	}
}

// ByFollowing orders the results by following terms.
func ByFollowing(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFollowingStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFollowersCount orders the results by followers count.
func ByFollowersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFollowersStep(), opts...)
	}
}

// ByFollowers orders the results by followers terms.
func ByFollowers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFollowersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByBlockingCount orders the results by blocking count.
func ByBlockingCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBlockingStep(), opts...)
	}
}

// ByBlocking orders the results by blocking terms.
func ByBlocking(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBlockingStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByBlockedByCount orders the results by blocked_by count.
func ByBlockedByCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBlockedByStep(), opts...)
	}
}

// ByBlockedBy orders the results by blocked_by terms.
func ByBlockedBy(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBlockedByStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDailyTasksCount orders the results by daily_tasks count.
func ByDailyTasksCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDailyTasksStep(), opts...)
	}
}

// ByDailyTasks orders the results by daily_tasks terms.
func ByDailyTasks(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDailyTasksStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDeviceTokensCount orders the results by device_tokens count.
func ByDeviceTokensCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDeviceTokensStep(), opts...)
	}
}

// ByDeviceTokens orders the results by device_tokens terms.
func ByDeviceTokens(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDeviceTokensStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newPostsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PostsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, PostsTable, PostsColumn),
	)
}
func newCommentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CommentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, CommentsTable, CommentsColumn),
	)
}
func newLikesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LikesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, LikesTable, LikesColumn),
	)
}
func newPetsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PetsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, PetsTable, PetsColumn),
	)
}
func newFollowingStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FollowingInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FollowingTable, FollowingColumn),
	)
}
func newFollowersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FollowersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FollowersTable, FollowersColumn),
	)
}
func newBlockingStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BlockingInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BlockingTable, BlockingColumn),
	)
}
func newBlockedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BlockedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BlockedByTable, BlockedByColumn),
	)
}
func newDailyTasksStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DailyTasksInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, DailyTasksTable, DailyTasksColumn),
	)
}
func newDeviceTokensStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DeviceTokensInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, DeviceTokensTable, DeviceTokensColumn),
	)
}
