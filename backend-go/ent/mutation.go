// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/aki-13627/animalia/backend-go/ent/blockrelation"
	"github.com/aki-13627/animalia/backend-go/ent/comment"
	"github.com/aki-13627/animalia/backend-go/ent/dailytask"
	"github.com/aki-13627/animalia/backend-go/ent/devicetoken"
	"github.com/aki-13627/animalia/backend-go/ent/enum"
	"github.com/aki-13627/animalia/backend-go/ent/followrelation"
	"github.com/aki-13627/animalia/backend-go/ent/like"
	"github.com/aki-13627/animalia/backend-go/ent/pet"
	"github.com/aki-13627/animalia/backend-go/ent/post"
	"github.com/aki-13627/animalia/backend-go/ent/predicate"
	"github.com/aki-13627/animalia/backend-go/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockRelation  = "BlockRelation"
	TypeComment        = "Comment"
	TypeDailyTask      = "DailyTask"
	TypeDeviceToken    = "DeviceToken"
	TypeFollowRelation = "FollowRelation"
	TypeLike           = "Like"
	TypePet            = "Pet"
	TypePost           = "Post"
	TypeUser           = "User"
)

// BlockRelationMutation represents an operation that mutates the BlockRelation nodes in the graph.
type BlockRelationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	clearedFields map[string]struct{}
	from          *uuid.UUID
	clearedfrom   bool
	to            *uuid.UUID
	clearedto     bool
	done          bool
	oldValue      func(context.Context) (*BlockRelation, error)
	predicates    []predicate.BlockRelation
}

var _ ent.Mutation = (*BlockRelationMutation)(nil)

// blockrelationOption allows management of the mutation configuration using functional options.
type blockrelationOption func(*BlockRelationMutation)

// newBlockRelationMutation creates new mutation for the BlockRelation entity.
func newBlockRelationMutation(c config, op Op, opts ...blockrelationOption) *BlockRelationMutation {
	m := &BlockRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockRelationID sets the ID field of the mutation.
func withBlockRelationID(id uuid.UUID) blockrelationOption {
	return func(m *BlockRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockRelation
		)
		m.oldValue = func(ctx context.Context) (*BlockRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockRelation sets the old BlockRelation of the mutation.
func withBlockRelation(node *BlockRelation) blockrelationOption {
	return func(m *BlockRelationMutation) {
		m.oldValue = func(context.Context) (*BlockRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockRelation entities.
func (m *BlockRelationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockRelationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockRelationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockRelationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockRelationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockRelation entity.
// If the BlockRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockRelationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockRelationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFromID sets the "from" edge to the User entity by id.
func (m *BlockRelationMutation) SetFromID(id uuid.UUID) {
	m.from = &id
}

// ClearFrom clears the "from" edge to the User entity.
func (m *BlockRelationMutation) ClearFrom() {
	m.clearedfrom = true
}

// FromCleared reports if the "from" edge to the User entity was cleared.
func (m *BlockRelationMutation) FromCleared() bool {
	return m.clearedfrom
}

// FromID returns the "from" edge ID in the mutation.
func (m *BlockRelationMutation) FromID() (id uuid.UUID, exists bool) {
	if m.from != nil {
		return *m.from, true
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromID instead. It exists only for internal usage by the builders.
func (m *BlockRelationMutation) FromIDs() (ids []uuid.UUID) {
	if id := m.from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *BlockRelationMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
}

// SetToID sets the "to" edge to the User entity by id.
func (m *BlockRelationMutation) SetToID(id uuid.UUID) {
	m.to = &id
}

// ClearTo clears the "to" edge to the User entity.
func (m *BlockRelationMutation) ClearTo() {
	m.clearedto = true
}

// ToCleared reports if the "to" edge to the User entity was cleared.
func (m *BlockRelationMutation) ToCleared() bool {
	return m.clearedto
}

// ToID returns the "to" edge ID in the mutation.
func (m *BlockRelationMutation) ToID() (id uuid.UUID, exists bool) {
	if m.to != nil {
		return *m.to, true
	}
	return
}

// ToIDs returns the "to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToID instead. It exists only for internal usage by the builders.
func (m *BlockRelationMutation) ToIDs() (ids []uuid.UUID) {
	if id := m.to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTo resets all changes to the "to" edge.
func (m *BlockRelationMutation) ResetTo() {
	m.to = nil
	m.clearedto = false
}

// Where appends a list predicates to the BlockRelationMutation builder.
func (m *BlockRelationMutation) Where(ps ...predicate.BlockRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockRelation).
func (m *BlockRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockRelationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, blockrelation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockrelation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockrelation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockrelation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockRelationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockRelationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockRelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockRelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockRelationMutation) ResetField(name string) error {
	switch name {
	case blockrelation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from != nil {
		edges = append(edges, blockrelation.EdgeFrom)
	}
	if m.to != nil {
		edges = append(edges, blockrelation.EdgeTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockrelation.EdgeFrom:
		if id := m.from; id != nil {
			return []ent.Value{*id}
		}
	case blockrelation.EdgeTo:
		if id := m.to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom {
		edges = append(edges, blockrelation.EdgeFrom)
	}
	if m.clearedto {
		edges = append(edges, blockrelation.EdgeTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case blockrelation.EdgeFrom:
		return m.clearedfrom
	case blockrelation.EdgeTo:
		return m.clearedto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockRelationMutation) ClearEdge(name string) error {
	switch name {
	case blockrelation.EdgeFrom:
		m.ClearFrom()
		return nil
	case blockrelation.EdgeTo:
		m.ClearTo()
		return nil
	}
	return fmt.Errorf("unknown BlockRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockRelationMutation) ResetEdge(name string) error {
	switch name {
	case blockrelation.EdgeFrom:
		m.ResetFrom()
		return nil
	case blockrelation.EdgeTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown BlockRelation edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	content       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	post          *uuid.UUID
	clearedpost   bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uuid.UUID) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *CommentMutation) SetPostID(id uuid.UUID) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *CommentMutation) PostID() (id uuid.UUID, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) PostIDs() (ids []uuid.UUID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CommentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CommentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldContent:
		return m.Content()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgePost:
		return m.clearedpost
	case comment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgePost:
		m.ClearPost()
		return nil
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgePost:
		m.ResetPost()
		return nil
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DailyTaskMutation represents an operation that mutates the DailyTask nodes in the graph.
type DailyTaskMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	target_date   *time.Time
	_type         *enum.TaskType
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	post          *uuid.UUID
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*DailyTask, error)
	predicates    []predicate.DailyTask
}

var _ ent.Mutation = (*DailyTaskMutation)(nil)

// dailytaskOption allows management of the mutation configuration using functional options.
type dailytaskOption func(*DailyTaskMutation)

// newDailyTaskMutation creates new mutation for the DailyTask entity.
func newDailyTaskMutation(c config, op Op, opts ...dailytaskOption) *DailyTaskMutation {
	m := &DailyTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeDailyTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDailyTaskID sets the ID field of the mutation.
func withDailyTaskID(id uuid.UUID) dailytaskOption {
	return func(m *DailyTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *DailyTask
		)
		m.oldValue = func(ctx context.Context) (*DailyTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DailyTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDailyTask sets the old DailyTask of the mutation.
func withDailyTask(node *DailyTask) dailytaskOption {
	return func(m *DailyTaskMutation) {
		m.oldValue = func(context.Context) (*DailyTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DailyTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DailyTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DailyTask entities.
func (m *DailyTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DailyTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DailyTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DailyTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DailyTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DailyTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DailyTask entity.
// If the DailyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DailyTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTargetDate sets the "target_date" field.
func (m *DailyTaskMutation) SetTargetDate(t time.Time) {
	m.target_date = &t
}

// TargetDate returns the value of the "target_date" field in the mutation.
func (m *DailyTaskMutation) TargetDate() (r time.Time, exists bool) {
	v := m.target_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDate returns the old "target_date" field's value of the DailyTask entity.
// If the DailyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyTaskMutation) OldTargetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDate: %w", err)
	}
	return oldValue.TargetDate, nil
}

// ResetTargetDate resets all changes to the "target_date" field.
func (m *DailyTaskMutation) ResetTargetDate() {
	m.target_date = nil
}

// SetType sets the "type" field.
func (m *DailyTaskMutation) SetType(et enum.TaskType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *DailyTaskMutation) GetType() (r enum.TaskType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DailyTask entity.
// If the DailyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyTaskMutation) OldType(ctx context.Context) (v enum.TaskType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DailyTaskMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *DailyTaskMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *DailyTaskMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DailyTaskMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *DailyTaskMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DailyTaskMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DailyTaskMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *DailyTaskMutation) SetPostID(id uuid.UUID) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *DailyTaskMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *DailyTaskMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *DailyTaskMutation) PostID() (id uuid.UUID, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *DailyTaskMutation) PostIDs() (ids []uuid.UUID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *DailyTaskMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the DailyTaskMutation builder.
func (m *DailyTaskMutation) Where(ps ...predicate.DailyTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DailyTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DailyTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DailyTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DailyTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DailyTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DailyTask).
func (m *DailyTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DailyTaskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, dailytask.FieldCreatedAt)
	}
	if m.target_date != nil {
		fields = append(fields, dailytask.FieldTargetDate)
	}
	if m._type != nil {
		fields = append(fields, dailytask.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DailyTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dailytask.FieldCreatedAt:
		return m.CreatedAt()
	case dailytask.FieldTargetDate:
		return m.TargetDate()
	case dailytask.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DailyTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dailytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dailytask.FieldTargetDate:
		return m.OldTargetDate(ctx)
	case dailytask.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown DailyTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dailytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dailytask.FieldTargetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDate(v)
		return nil
	case dailytask.FieldType:
		v, ok := value.(enum.TaskType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown DailyTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DailyTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DailyTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DailyTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DailyTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DailyTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DailyTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DailyTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DailyTaskMutation) ResetField(name string) error {
	switch name {
	case dailytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dailytask.FieldTargetDate:
		m.ResetTargetDate()
		return nil
	case dailytask.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown DailyTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DailyTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, dailytask.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, dailytask.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DailyTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dailytask.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case dailytask.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DailyTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DailyTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DailyTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, dailytask.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, dailytask.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DailyTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case dailytask.EdgeUser:
		return m.cleareduser
	case dailytask.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DailyTaskMutation) ClearEdge(name string) error {
	switch name {
	case dailytask.EdgeUser:
		m.ClearUser()
		return nil
	case dailytask.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown DailyTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DailyTaskMutation) ResetEdge(name string) error {
	switch name {
	case dailytask.EdgeUser:
		m.ResetUser()
		return nil
	case dailytask.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown DailyTask edge %s", name)
}

// DeviceTokenMutation represents an operation that mutates the DeviceToken nodes in the graph.
type DeviceTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	device_id     *string
	token         *string
	platform      *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*DeviceToken, error)
	predicates    []predicate.DeviceToken
}

var _ ent.Mutation = (*DeviceTokenMutation)(nil)

// devicetokenOption allows management of the mutation configuration using functional options.
type devicetokenOption func(*DeviceTokenMutation)

// newDeviceTokenMutation creates new mutation for the DeviceToken entity.
func newDeviceTokenMutation(c config, op Op, opts ...devicetokenOption) *DeviceTokenMutation {
	m := &DeviceTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceTokenID sets the ID field of the mutation.
func withDeviceTokenID(id uuid.UUID) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceToken
		)
		m.oldValue = func(ctx context.Context) (*DeviceToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceToken sets the old DeviceToken of the mutation.
func withDeviceToken(node *DeviceToken) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		m.oldValue = func(context.Context) (*DeviceToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceToken entities.
func (m *DeviceTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *DeviceTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceTokenMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceTokenMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceTokenMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceTokenMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetToken sets the "token" field.
func (m *DeviceTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *DeviceTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *DeviceTokenMutation) ResetToken() {
	m.token = nil
}

// SetPlatform sets the "platform" field.
func (m *DeviceTokenMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *DeviceTokenMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *DeviceTokenMutation) ResetPlatform() {
	m.platform = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[devicetoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceTokenMutation builder.
func (m *DeviceTokenMutation) Where(ps ...predicate.DeviceToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceToken).
func (m *DeviceTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, devicetoken.FieldUserID)
	}
	if m.device_id != nil {
		fields = append(fields, devicetoken.FieldDeviceID)
	}
	if m.token != nil {
		fields = append(fields, devicetoken.FieldToken)
	}
	if m.platform != nil {
		fields = append(fields, devicetoken.FieldPlatform)
	}
	if m.created_at != nil {
		fields = append(fields, devicetoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicetoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicetoken.FieldUserID:
		return m.UserID()
	case devicetoken.FieldDeviceID:
		return m.DeviceID()
	case devicetoken.FieldToken:
		return m.Token()
	case devicetoken.FieldPlatform:
		return m.Platform()
	case devicetoken.FieldCreatedAt:
		return m.CreatedAt()
	case devicetoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicetoken.FieldUserID:
		return m.OldUserID(ctx)
	case devicetoken.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicetoken.FieldToken:
		return m.OldToken(ctx)
	case devicetoken.FieldPlatform:
		return m.OldPlatform(ctx)
	case devicetoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicetoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicetoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case devicetoken.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicetoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case devicetoken.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case devicetoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicetoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ResetField(name string) error {
	switch name {
	case devicetoken.FieldUserID:
		m.ResetUserID()
		return nil
	case devicetoken.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicetoken.FieldToken:
		m.ResetToken()
		return nil
	case devicetoken.FieldPlatform:
		m.ResetPlatform()
		return nil
	case devicetoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicetoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, devicetoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicetoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, devicetoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case devicetoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceTokenMutation) ClearEdge(name string) error {
	switch name {
	case devicetoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceTokenMutation) ResetEdge(name string) error {
	switch name {
	case devicetoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken edge %s", name)
}

// FollowRelationMutation represents an operation that mutates the FollowRelation nodes in the graph.
type FollowRelationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	clearedFields map[string]struct{}
	from          *uuid.UUID
	clearedfrom   bool
	to            *uuid.UUID
	clearedto     bool
	done          bool
	oldValue      func(context.Context) (*FollowRelation, error)
	predicates    []predicate.FollowRelation
}

var _ ent.Mutation = (*FollowRelationMutation)(nil)

// followrelationOption allows management of the mutation configuration using functional options.
type followrelationOption func(*FollowRelationMutation)

// newFollowRelationMutation creates new mutation for the FollowRelation entity.
func newFollowRelationMutation(c config, op Op, opts ...followrelationOption) *FollowRelationMutation {
	m := &FollowRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeFollowRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowRelationID sets the ID field of the mutation.
func withFollowRelationID(id uuid.UUID) followrelationOption {
	return func(m *FollowRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *FollowRelation
		)
		m.oldValue = func(ctx context.Context) (*FollowRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FollowRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollowRelation sets the old FollowRelation of the mutation.
func withFollowRelation(node *FollowRelation) followrelationOption {
	return func(m *FollowRelationMutation) {
		m.oldValue = func(context.Context) (*FollowRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FollowRelation entities.
func (m *FollowRelationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowRelationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowRelationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FollowRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FollowRelationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FollowRelationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FollowRelation entity.
// If the FollowRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowRelationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FollowRelationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFromID sets the "from" edge to the User entity by id.
func (m *FollowRelationMutation) SetFromID(id uuid.UUID) {
	m.from = &id
}

// ClearFrom clears the "from" edge to the User entity.
func (m *FollowRelationMutation) ClearFrom() {
	m.clearedfrom = true
}

// FromCleared reports if the "from" edge to the User entity was cleared.
func (m *FollowRelationMutation) FromCleared() bool {
	return m.clearedfrom
}

// FromID returns the "from" edge ID in the mutation.
func (m *FollowRelationMutation) FromID() (id uuid.UUID, exists bool) {
	if m.from != nil {
		return *m.from, true
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromID instead. It exists only for internal usage by the builders.
func (m *FollowRelationMutation) FromIDs() (ids []uuid.UUID) {
	if id := m.from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *FollowRelationMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
}

// SetToID sets the "to" edge to the User entity by id.
func (m *FollowRelationMutation) SetToID(id uuid.UUID) {
	m.to = &id
}

// ClearTo clears the "to" edge to the User entity.
func (m *FollowRelationMutation) ClearTo() {
	m.clearedto = true
}

// ToCleared reports if the "to" edge to the User entity was cleared.
func (m *FollowRelationMutation) ToCleared() bool {
	return m.clearedto
}

// ToID returns the "to" edge ID in the mutation.
func (m *FollowRelationMutation) ToID() (id uuid.UUID, exists bool) {
	if m.to != nil {
		return *m.to, true
	}
	return
}

// ToIDs returns the "to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToID instead. It exists only for internal usage by the builders.
func (m *FollowRelationMutation) ToIDs() (ids []uuid.UUID) {
	if id := m.to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTo resets all changes to the "to" edge.
func (m *FollowRelationMutation) ResetTo() {
	m.to = nil
	m.clearedto = false
}

// Where appends a list predicates to the FollowRelationMutation builder.
func (m *FollowRelationMutation) Where(ps ...predicate.FollowRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FollowRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FollowRelation).
func (m *FollowRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowRelationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, followrelation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case followrelation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case followrelation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FollowRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case followrelation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FollowRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowRelationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowRelationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FollowRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowRelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowRelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FollowRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowRelationMutation) ResetField(name string) error {
	switch name {
	case followrelation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FollowRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from != nil {
		edges = append(edges, followrelation.EdgeFrom)
	}
	if m.to != nil {
		edges = append(edges, followrelation.EdgeTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case followrelation.EdgeFrom:
		if id := m.from; id != nil {
			return []ent.Value{*id}
		}
	case followrelation.EdgeTo:
		if id := m.to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom {
		edges = append(edges, followrelation.EdgeFrom)
	}
	if m.clearedto {
		edges = append(edges, followrelation.EdgeTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case followrelation.EdgeFrom:
		return m.clearedfrom
	case followrelation.EdgeTo:
		return m.clearedto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowRelationMutation) ClearEdge(name string) error {
	switch name {
	case followrelation.EdgeFrom:
		m.ClearFrom()
		return nil
	case followrelation.EdgeTo:
		m.ClearTo()
		return nil
	}
	return fmt.Errorf("unknown FollowRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowRelationMutation) ResetEdge(name string) error {
	switch name {
	case followrelation.EdgeFrom:
		m.ResetFrom()
		return nil
	case followrelation.EdgeTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown FollowRelation edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	post          *uuid.UUID
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id uuid.UUID) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LikeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LikeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LikeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *LikeMutation) SetPostID(id uuid.UUID) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *LikeMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *LikeMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *LikeMutation) PostID() (id uuid.UUID, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) PostIDs() (ids []uuid.UUID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *LikeMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Like, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, like.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case like.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, like.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	switch name {
	case like.EdgeUser:
		return m.cleareduser
	case like.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ClearUser()
		return nil
	case like.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ResetUser()
		return nil
	case like.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Like edge %s", name)
}

// PetMutation represents an operation that mutates the Pet nodes in the graph.
type PetMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	birth_day     *string
	_type         *pet.Type
	species       *pet.Species
	image_key     *string
	created_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Pet, error)
	predicates    []predicate.Pet
}

var _ ent.Mutation = (*PetMutation)(nil)

// petOption allows management of the mutation configuration using functional options.
type petOption func(*PetMutation)

// newPetMutation creates new mutation for the Pet entity.
func newPetMutation(c config, op Op, opts ...petOption) *PetMutation {
	m := &PetMutation{
		config:        c,
		op:            op,
		typ:           TypePet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetID sets the ID field of the mutation.
func withPetID(id uuid.UUID) petOption {
	return func(m *PetMutation) {
		var (
			err   error
			once  sync.Once
			value *Pet
		)
		m.oldValue = func(ctx context.Context) (*Pet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPet sets the old Pet of the mutation.
func withPet(node *Pet) petOption {
	return func(m *PetMutation) {
		m.oldValue = func(context.Context) (*Pet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pet entities.
func (m *PetMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PetMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PetMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PetMutation) ResetName() {
	m.name = nil
}

// SetBirthDay sets the "birth_day" field.
func (m *PetMutation) SetBirthDay(s string) {
	m.birth_day = &s
}

// BirthDay returns the value of the "birth_day" field in the mutation.
func (m *PetMutation) BirthDay() (r string, exists bool) {
	v := m.birth_day
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDay returns the old "birth_day" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldBirthDay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDay: %w", err)
	}
	return oldValue.BirthDay, nil
}

// ResetBirthDay resets all changes to the "birth_day" field.
func (m *PetMutation) ResetBirthDay() {
	m.birth_day = nil
}

// SetType sets the "type" field.
func (m *PetMutation) SetType(pe pet.Type) {
	m._type = &pe
}

// GetType returns the value of the "type" field in the mutation.
func (m *PetMutation) GetType() (r pet.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldType(ctx context.Context) (v pet.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PetMutation) ResetType() {
	m._type = nil
}

// SetSpecies sets the "species" field.
func (m *PetMutation) SetSpecies(pe pet.Species) {
	m.species = &pe
}

// Species returns the value of the "species" field in the mutation.
func (m *PetMutation) Species() (r pet.Species, exists bool) {
	v := m.species
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecies returns the old "species" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldSpecies(ctx context.Context) (v pet.Species, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecies: %w", err)
	}
	return oldValue.Species, nil
}

// ResetSpecies resets all changes to the "species" field.
func (m *PetMutation) ResetSpecies() {
	m.species = nil
}

// SetImageKey sets the "image_key" field.
func (m *PetMutation) SetImageKey(s string) {
	m.image_key = &s
}

// ImageKey returns the value of the "image_key" field in the mutation.
func (m *PetMutation) ImageKey() (r string, exists bool) {
	v := m.image_key
	if v == nil {
		return
	}
	return *v, true
}

// OldImageKey returns the old "image_key" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldImageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageKey: %w", err)
	}
	return oldValue.ImageKey, nil
}

// ResetImageKey resets all changes to the "image_key" field.
func (m *PetMutation) ResetImageKey() {
	m.image_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pet.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pet.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pet.FieldDeletedAt)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *PetMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PetMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PetMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PetMutation builder.
func (m *PetMutation) Where(ps ...predicate.Pet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pet).
func (m *PetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, pet.FieldName)
	}
	if m.birth_day != nil {
		fields = append(fields, pet.FieldBirthDay)
	}
	if m._type != nil {
		fields = append(fields, pet.FieldType)
	}
	if m.species != nil {
		fields = append(fields, pet.FieldSpecies)
	}
	if m.image_key != nil {
		fields = append(fields, pet.FieldImageKey)
	}
	if m.created_at != nil {
		fields = append(fields, pet.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pet.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pet.FieldName:
		return m.Name()
	case pet.FieldBirthDay:
		return m.BirthDay()
	case pet.FieldType:
		return m.GetType()
	case pet.FieldSpecies:
		return m.Species()
	case pet.FieldImageKey:
		return m.ImageKey()
	case pet.FieldCreatedAt:
		return m.CreatedAt()
	case pet.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pet.FieldName:
		return m.OldName(ctx)
	case pet.FieldBirthDay:
		return m.OldBirthDay(ctx)
	case pet.FieldType:
		return m.OldType(ctx)
	case pet.FieldSpecies:
		return m.OldSpecies(ctx)
	case pet.FieldImageKey:
		return m.OldImageKey(ctx)
	case pet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Pet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pet.FieldBirthDay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDay(v)
		return nil
	case pet.FieldType:
		v, ok := value.(pet.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pet.FieldSpecies:
		v, ok := value.(pet.Species)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecies(v)
		return nil
	case pet.FieldImageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageKey(v)
		return nil
	case pet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pet.FieldDeletedAt) {
		fields = append(fields, pet.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetMutation) ClearField(name string) error {
	switch name {
	case pet.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Pet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PetMutation) ResetField(name string) error {
	switch name {
	case pet.FieldName:
		m.ResetName()
		return nil
	case pet.FieldBirthDay:
		m.ResetBirthDay()
		return nil
	case pet.FieldType:
		m.ResetType()
		return nil
	case pet.FieldSpecies:
		m.ResetSpecies()
		return nil
	case pet.FieldImageKey:
		m.ResetImageKey()
		return nil
	case pet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, pet.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pet.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, pet.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PetMutation) EdgeCleared(name string) bool {
	switch name {
	case pet.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PetMutation) ClearEdge(name string) error {
	switch name {
	case pet.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Pet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PetMutation) ResetEdge(name string) error {
	switch name {
	case pet.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Pet edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	index             *uint32
	addindex          *int32
	caption           *string
	image_key         *string
	created_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	comments          map[uuid.UUID]struct{}
	removedcomments   map[uuid.UUID]struct{}
	clearedcomments   bool
	likes             map[uuid.UUID]struct{}
	removedlikes      map[uuid.UUID]struct{}
	clearedlikes      bool
	daily_task        *uuid.UUID
	cleareddaily_task bool
	done              bool
	oldValue          func(context.Context) (*Post, error)
	predicates        []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id uuid.UUID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndex sets the "index" field.
func (m *PostMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *PostMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *PostMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *PostMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *PostMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[post.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *PostMutation) IndexCleared() bool {
	_, ok := m.clearedFields[post.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *PostMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, post.FieldIndex)
}

// SetCaption sets the "caption" field.
func (m *PostMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *PostMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ResetCaption resets all changes to the "caption" field.
func (m *PostMutation) ResetCaption() {
	m.caption = nil
}

// SetImageKey sets the "image_key" field.
func (m *PostMutation) SetImageKey(s string) {
	m.image_key = &s
}

// ImageKey returns the value of the "image_key" field in the mutation.
func (m *PostMutation) ImageKey() (r string, exists bool) {
	v := m.image_key
	if v == nil {
		return
	}
	return *v, true
}

// OldImageKey returns the old "image_key" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldImageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageKey: %w", err)
	}
	return oldValue.ImageKey, nil
}

// ResetImageKey resets all changes to the "image_key" field.
func (m *PostMutation) ResetImageKey() {
	m.image_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PostMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PostMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PostMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *PostMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *PostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *PostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *PostMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *PostMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *PostMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *PostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...uuid.UUID) {
	if m.likes == nil {
		m.likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...uuid.UUID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *PostMutation) RemovedLikesIDs() (ids []uuid.UUID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []uuid.UUID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// SetDailyTaskID sets the "daily_task" edge to the DailyTask entity by id.
func (m *PostMutation) SetDailyTaskID(id uuid.UUID) {
	m.daily_task = &id
}

// ClearDailyTask clears the "daily_task" edge to the DailyTask entity.
func (m *PostMutation) ClearDailyTask() {
	m.cleareddaily_task = true
}

// DailyTaskCleared reports if the "daily_task" edge to the DailyTask entity was cleared.
func (m *PostMutation) DailyTaskCleared() bool {
	return m.cleareddaily_task
}

// DailyTaskID returns the "daily_task" edge ID in the mutation.
func (m *PostMutation) DailyTaskID() (id uuid.UUID, exists bool) {
	if m.daily_task != nil {
		return *m.daily_task, true
	}
	return
}

// DailyTaskIDs returns the "daily_task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DailyTaskID instead. It exists only for internal usage by the builders.
func (m *PostMutation) DailyTaskIDs() (ids []uuid.UUID) {
	if id := m.daily_task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDailyTask resets all changes to the "daily_task" edge.
func (m *PostMutation) ResetDailyTask() {
	m.daily_task = nil
	m.cleareddaily_task = false
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.index != nil {
		fields = append(fields, post.FieldIndex)
	}
	if m.caption != nil {
		fields = append(fields, post.FieldCaption)
	}
	if m.image_key != nil {
		fields = append(fields, post.FieldImageKey)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldIndex:
		return m.Index()
	case post.FieldCaption:
		return m.Caption()
	case post.FieldImageKey:
		return m.ImageKey()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldIndex:
		return m.OldIndex(ctx)
	case post.FieldCaption:
		return m.OldCaption(ctx)
	case post.FieldImageKey:
		return m.OldImageKey(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case post.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case post.FieldImageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageKey(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, post.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldIndex) {
		fields = append(fields, post.FieldIndex)
	}
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldIndex:
		m.ClearIndex()
		return nil
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldIndex:
		m.ResetIndex()
		return nil
	case post.FieldCaption:
		m.ResetCaption()
		return nil
	case post.FieldImageKey:
		m.ResetImageKey()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, post.EdgeUser)
	}
	if m.comments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.daily_task != nil {
		edges = append(edges, post.EdgeDailyTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeDailyTask:
		if id := m.daily_task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, post.EdgeUser)
	}
	if m.clearedcomments {
		edges = append(edges, post.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.cleareddaily_task {
		edges = append(edges, post.EdgeDailyTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeUser:
		return m.cleareduser
	case post.EdgeComments:
		return m.clearedcomments
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeDailyTask:
		return m.cleareddaily_task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ClearUser()
		return nil
	case post.EdgeDailyTask:
		m.ClearDailyTask()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ResetUser()
		return nil
	case post.EdgeComments:
		m.ResetComments()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeDailyTask:
		m.ResetDailyTask()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	index                *uint32
	addindex             *int32
	email                *string
	name                 *string
	bio                  *string
	streak_count         *uint32
	addstreak_count      *int32
	icon_image_key       *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	posts                map[uuid.UUID]struct{}
	removedposts         map[uuid.UUID]struct{}
	clearedposts         bool
	comments             map[uuid.UUID]struct{}
	removedcomments      map[uuid.UUID]struct{}
	clearedcomments      bool
	likes                map[uuid.UUID]struct{}
	removedlikes         map[uuid.UUID]struct{}
	clearedlikes         bool
	pets                 map[uuid.UUID]struct{}
	removedpets          map[uuid.UUID]struct{}
	clearedpets          bool
	following            map[uuid.UUID]struct{}
	removedfollowing     map[uuid.UUID]struct{}
	clearedfollowing     bool
	followers            map[uuid.UUID]struct{}
	removedfollowers     map[uuid.UUID]struct{}
	clearedfollowers     bool
	blocking             map[uuid.UUID]struct{}
	removedblocking      map[uuid.UUID]struct{}
	clearedblocking      bool
	blocked_by           map[uuid.UUID]struct{}
	removedblocked_by    map[uuid.UUID]struct{}
	clearedblocked_by    bool
	daily_tasks          map[uuid.UUID]struct{}
	removeddaily_tasks   map[uuid.UUID]struct{}
	cleareddaily_tasks   bool
	device_tokens        map[uuid.UUID]struct{}
	removeddevice_tokens map[uuid.UUID]struct{}
	cleareddevice_tokens bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndex sets the "index" field.
func (m *UserMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *UserMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *UserMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *UserMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *UserMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[user.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *UserMutation) IndexCleared() bool {
	_, ok := m.clearedFields[user.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *UserMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, user.FieldIndex)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
}

// SetStreakCount sets the "streak_count" field.
func (m *UserMutation) SetStreakCount(u uint32) {
	m.streak_count = &u
	m.addstreak_count = nil
}

// StreakCount returns the value of the "streak_count" field in the mutation.
func (m *UserMutation) StreakCount() (r uint32, exists bool) {
	v := m.streak_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakCount returns the old "streak_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStreakCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakCount: %w", err)
	}
	return oldValue.StreakCount, nil
}

// AddStreakCount adds u to the "streak_count" field.
func (m *UserMutation) AddStreakCount(u int32) {
	if m.addstreak_count != nil {
		*m.addstreak_count += u
	} else {
		m.addstreak_count = &u
	}
}

// AddedStreakCount returns the value that was added to the "streak_count" field in this mutation.
func (m *UserMutation) AddedStreakCount() (r int32, exists bool) {
	v := m.addstreak_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreakCount resets all changes to the "streak_count" field.
func (m *UserMutation) ResetStreakCount() {
	m.streak_count = nil
	m.addstreak_count = nil
}

// SetIconImageKey sets the "icon_image_key" field.
func (m *UserMutation) SetIconImageKey(s string) {
	m.icon_image_key = &s
}

// IconImageKey returns the value of the "icon_image_key" field in the mutation.
func (m *UserMutation) IconImageKey() (r string, exists bool) {
	v := m.icon_image_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageKey returns the old "icon_image_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIconImageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageKey: %w", err)
	}
	return oldValue.IconImageKey, nil
}

// ClearIconImageKey clears the value of the "icon_image_key" field.
func (m *UserMutation) ClearIconImageKey() {
	m.icon_image_key = nil
	m.clearedFields[user.FieldIconImageKey] = struct{}{}
}

// IconImageKeyCleared returns if the "icon_image_key" field was cleared in this mutation.
func (m *UserMutation) IconImageKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldIconImageKey]
	return ok
}

// ResetIconImageKey resets all changes to the "icon_image_key" field.
func (m *UserMutation) ResetIconImageKey() {
	m.icon_image_key = nil
	delete(m.clearedFields, user.FieldIconImageKey)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *UserMutation) AddLikeIDs(ids ...uuid.UUID) {
	if m.likes == nil {
		m.likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *UserMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *UserMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *UserMutation) RemoveLikeIDs(ids ...uuid.UUID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *UserMutation) RemovedLikesIDs() (ids []uuid.UUID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *UserMutation) LikesIDs() (ids []uuid.UUID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *UserMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddPetIDs adds the "pets" edge to the Pet entity by ids.
func (m *UserMutation) AddPetIDs(ids ...uuid.UUID) {
	if m.pets == nil {
		m.pets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pets[ids[i]] = struct{}{}
	}
}

// ClearPets clears the "pets" edge to the Pet entity.
func (m *UserMutation) ClearPets() {
	m.clearedpets = true
}

// PetsCleared reports if the "pets" edge to the Pet entity was cleared.
func (m *UserMutation) PetsCleared() bool {
	return m.clearedpets
}

// RemovePetIDs removes the "pets" edge to the Pet entity by IDs.
func (m *UserMutation) RemovePetIDs(ids ...uuid.UUID) {
	if m.removedpets == nil {
		m.removedpets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pets, ids[i])
		m.removedpets[ids[i]] = struct{}{}
	}
}

// RemovedPets returns the removed IDs of the "pets" edge to the Pet entity.
func (m *UserMutation) RemovedPetsIDs() (ids []uuid.UUID) {
	for id := range m.removedpets {
		ids = append(ids, id)
	}
	return
}

// PetsIDs returns the "pets" edge IDs in the mutation.
func (m *UserMutation) PetsIDs() (ids []uuid.UUID) {
	for id := range m.pets {
		ids = append(ids, id)
	}
	return
}

// ResetPets resets all changes to the "pets" edge.
func (m *UserMutation) ResetPets() {
	m.pets = nil
	m.clearedpets = false
	m.removedpets = nil
}

// AddFollowingIDs adds the "following" edge to the FollowRelation entity by ids.
func (m *UserMutation) AddFollowingIDs(ids ...uuid.UUID) {
	if m.following == nil {
		m.following = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the FollowRelation entity.
func (m *UserMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the FollowRelation entity was cleared.
func (m *UserMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the FollowRelation entity by IDs.
func (m *UserMutation) RemoveFollowingIDs(ids ...uuid.UUID) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the FollowRelation entity.
func (m *UserMutation) RemovedFollowingIDs() (ids []uuid.UUID) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *UserMutation) FollowingIDs() (ids []uuid.UUID) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *UserMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddFollowerIDs adds the "followers" edge to the FollowRelation entity by ids.
func (m *UserMutation) AddFollowerIDs(ids ...uuid.UUID) {
	if m.followers == nil {
		m.followers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.followers[ids[i]] = struct{}{}
	}
}

// ClearFollowers clears the "followers" edge to the FollowRelation entity.
func (m *UserMutation) ClearFollowers() {
	m.clearedfollowers = true
}

// FollowersCleared reports if the "followers" edge to the FollowRelation entity was cleared.
func (m *UserMutation) FollowersCleared() bool {
	return m.clearedfollowers
}

// RemoveFollowerIDs removes the "followers" edge to the FollowRelation entity by IDs.
func (m *UserMutation) RemoveFollowerIDs(ids ...uuid.UUID) {
	if m.removedfollowers == nil {
		m.removedfollowers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.followers, ids[i])
		m.removedfollowers[ids[i]] = struct{}{}
	}
}

// RemovedFollowers returns the removed IDs of the "followers" edge to the FollowRelation entity.
func (m *UserMutation) RemovedFollowersIDs() (ids []uuid.UUID) {
	for id := range m.removedfollowers {
		ids = append(ids, id)
	}
	return
}

// FollowersIDs returns the "followers" edge IDs in the mutation.
func (m *UserMutation) FollowersIDs() (ids []uuid.UUID) {
	for id := range m.followers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowers resets all changes to the "followers" edge.
func (m *UserMutation) ResetFollowers() {
	m.followers = nil
	m.clearedfollowers = false
	m.removedfollowers = nil
}

// AddBlockingIDs adds the "blocking" edge to the BlockRelation entity by ids.
func (m *UserMutation) AddBlockingIDs(ids ...uuid.UUID) {
	if m.blocking == nil {
		m.blocking = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blocking[ids[i]] = struct{}{}
	}
}

// ClearBlocking clears the "blocking" edge to the BlockRelation entity.
func (m *UserMutation) ClearBlocking() {
	m.clearedblocking = true
}

// BlockingCleared reports if the "blocking" edge to the BlockRelation entity was cleared.
func (m *UserMutation) BlockingCleared() bool {
	return m.clearedblocking
}

// RemoveBlockingIDs removes the "blocking" edge to the BlockRelation entity by IDs.
func (m *UserMutation) RemoveBlockingIDs(ids ...uuid.UUID) {
	if m.removedblocking == nil {
		m.removedblocking = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blocking, ids[i])
		m.removedblocking[ids[i]] = struct{}{}
	}
}

// RemovedBlocking returns the removed IDs of the "blocking" edge to the BlockRelation entity.
func (m *UserMutation) RemovedBlockingIDs() (ids []uuid.UUID) {
	for id := range m.removedblocking {
		ids = append(ids, id)
	}
	return
}

// BlockingIDs returns the "blocking" edge IDs in the mutation.
func (m *UserMutation) BlockingIDs() (ids []uuid.UUID) {
	for id := range m.blocking {
		ids = append(ids, id)
	}
	return
}

// ResetBlocking resets all changes to the "blocking" edge.
func (m *UserMutation) ResetBlocking() {
	m.blocking = nil
	m.clearedblocking = false
	m.removedblocking = nil
}

// AddBlockedByIDs adds the "blocked_by" edge to the BlockRelation entity by ids.
func (m *UserMutation) AddBlockedByIDs(ids ...uuid.UUID) {
	if m.blocked_by == nil {
		m.blocked_by = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blocked_by[ids[i]] = struct{}{}
	}
}

// ClearBlockedBy clears the "blocked_by" edge to the BlockRelation entity.
func (m *UserMutation) ClearBlockedBy() {
	m.clearedblocked_by = true
}

// BlockedByCleared reports if the "blocked_by" edge to the BlockRelation entity was cleared.
func (m *UserMutation) BlockedByCleared() bool {
	return m.clearedblocked_by
}

// RemoveBlockedByIDs removes the "blocked_by" edge to the BlockRelation entity by IDs.
func (m *UserMutation) RemoveBlockedByIDs(ids ...uuid.UUID) {
	if m.removedblocked_by == nil {
		m.removedblocked_by = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blocked_by, ids[i])
		m.removedblocked_by[ids[i]] = struct{}{}
	}
}

// RemovedBlockedBy returns the removed IDs of the "blocked_by" edge to the BlockRelation entity.
func (m *UserMutation) RemovedBlockedByIDs() (ids []uuid.UUID) {
	for id := range m.removedblocked_by {
		ids = append(ids, id)
	}
	return
}

// BlockedByIDs returns the "blocked_by" edge IDs in the mutation.
func (m *UserMutation) BlockedByIDs() (ids []uuid.UUID) {
	for id := range m.blocked_by {
		ids = append(ids, id)
	}
	return
}

// ResetBlockedBy resets all changes to the "blocked_by" edge.
func (m *UserMutation) ResetBlockedBy() {
	m.blocked_by = nil
	m.clearedblocked_by = false
	m.removedblocked_by = nil
}

// AddDailyTaskIDs adds the "daily_tasks" edge to the DailyTask entity by ids.
func (m *UserMutation) AddDailyTaskIDs(ids ...uuid.UUID) {
	if m.daily_tasks == nil {
		m.daily_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.daily_tasks[ids[i]] = struct{}{}
	}
}

// ClearDailyTasks clears the "daily_tasks" edge to the DailyTask entity.
func (m *UserMutation) ClearDailyTasks() {
	m.cleareddaily_tasks = true
}

// DailyTasksCleared reports if the "daily_tasks" edge to the DailyTask entity was cleared.
func (m *UserMutation) DailyTasksCleared() bool {
	return m.cleareddaily_tasks
}

// RemoveDailyTaskIDs removes the "daily_tasks" edge to the DailyTask entity by IDs.
func (m *UserMutation) RemoveDailyTaskIDs(ids ...uuid.UUID) {
	if m.removeddaily_tasks == nil {
		m.removeddaily_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.daily_tasks, ids[i])
		m.removeddaily_tasks[ids[i]] = struct{}{}
	}
}

// RemovedDailyTasks returns the removed IDs of the "daily_tasks" edge to the DailyTask entity.
func (m *UserMutation) RemovedDailyTasksIDs() (ids []uuid.UUID) {
	for id := range m.removeddaily_tasks {
		ids = append(ids, id)
	}
	return
}

// DailyTasksIDs returns the "daily_tasks" edge IDs in the mutation.
func (m *UserMutation) DailyTasksIDs() (ids []uuid.UUID) {
	for id := range m.daily_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetDailyTasks resets all changes to the "daily_tasks" edge.
func (m *UserMutation) ResetDailyTasks() {
	m.daily_tasks = nil
	m.cleareddaily_tasks = false
	m.removeddaily_tasks = nil
}

// AddDeviceTokenIDs adds the "device_tokens" edge to the DeviceToken entity by ids.
func (m *UserMutation) AddDeviceTokenIDs(ids ...uuid.UUID) {
	if m.device_tokens == nil {
		m.device_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.device_tokens[ids[i]] = struct{}{}
	}
}

// ClearDeviceTokens clears the "device_tokens" edge to the DeviceToken entity.
func (m *UserMutation) ClearDeviceTokens() {
	m.cleareddevice_tokens = true
}

// DeviceTokensCleared reports if the "device_tokens" edge to the DeviceToken entity was cleared.
func (m *UserMutation) DeviceTokensCleared() bool {
	return m.cleareddevice_tokens
}

// RemoveDeviceTokenIDs removes the "device_tokens" edge to the DeviceToken entity by IDs.
func (m *UserMutation) RemoveDeviceTokenIDs(ids ...uuid.UUID) {
	if m.removeddevice_tokens == nil {
		m.removeddevice_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.device_tokens, ids[i])
		m.removeddevice_tokens[ids[i]] = struct{}{}
	}
}

// RemovedDeviceTokens returns the removed IDs of the "device_tokens" edge to the DeviceToken entity.
func (m *UserMutation) RemovedDeviceTokensIDs() (ids []uuid.UUID) {
	for id := range m.removeddevice_tokens {
		ids = append(ids, id)
	}
	return
}

// DeviceTokensIDs returns the "device_tokens" edge IDs in the mutation.
func (m *UserMutation) DeviceTokensIDs() (ids []uuid.UUID) {
	for id := range m.device_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceTokens resets all changes to the "device_tokens" edge.
func (m *UserMutation) ResetDeviceTokens() {
	m.device_tokens = nil
	m.cleareddevice_tokens = false
	m.removeddevice_tokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.index != nil {
		fields = append(fields, user.FieldIndex)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.streak_count != nil {
		fields = append(fields, user.FieldStreakCount)
	}
	if m.icon_image_key != nil {
		fields = append(fields, user.FieldIconImageKey)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIndex:
		return m.Index()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldBio:
		return m.Bio()
	case user.FieldStreakCount:
		return m.StreakCount()
	case user.FieldIconImageKey:
		return m.IconImageKey()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldIndex:
		return m.OldIndex(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldStreakCount:
		return m.OldStreakCount(ctx)
	case user.FieldIconImageKey:
		return m.OldIconImageKey(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldStreakCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakCount(v)
		return nil
	case user.FieldIconImageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageKey(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, user.FieldIndex)
	}
	if m.addstreak_count != nil {
		fields = append(fields, user.FieldStreakCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIndex:
		return m.AddedIndex()
	case user.FieldStreakCount:
		return m.AddedStreakCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case user.FieldStreakCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldIndex) {
		fields = append(fields, user.FieldIndex)
	}
	if m.FieldCleared(user.FieldIconImageKey) {
		fields = append(fields, user.FieldIconImageKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldIndex:
		m.ClearIndex()
		return nil
	case user.FieldIconImageKey:
		m.ClearIconImageKey()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldIndex:
		m.ResetIndex()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldStreakCount:
		m.ResetStreakCount()
		return nil
	case user.FieldIconImageKey:
		m.ResetIconImageKey()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.pets != nil {
		edges = append(edges, user.EdgePets)
	}
	if m.following != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.followers != nil {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.blocking != nil {
		edges = append(edges, user.EdgeBlocking)
	}
	if m.blocked_by != nil {
		edges = append(edges, user.EdgeBlockedBy)
	}
	if m.daily_tasks != nil {
		edges = append(edges, user.EdgeDailyTasks)
	}
	if m.device_tokens != nil {
		edges = append(edges, user.EdgeDeviceTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePets:
		ids := make([]ent.Value, 0, len(m.pets))
		for id := range m.pets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.followers))
		for id := range m.followers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocking:
		ids := make([]ent.Value, 0, len(m.blocking))
		for id := range m.blocking {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.blocked_by))
		for id := range m.blocked_by {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDailyTasks:
		ids := make([]ent.Value, 0, len(m.daily_tasks))
		for id := range m.daily_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceTokens:
		ids := make([]ent.Value, 0, len(m.device_tokens))
		for id := range m.device_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.removedpets != nil {
		edges = append(edges, user.EdgePets)
	}
	if m.removedfollowing != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.removedfollowers != nil {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.removedblocking != nil {
		edges = append(edges, user.EdgeBlocking)
	}
	if m.removedblocked_by != nil {
		edges = append(edges, user.EdgeBlockedBy)
	}
	if m.removeddaily_tasks != nil {
		edges = append(edges, user.EdgeDailyTasks)
	}
	if m.removeddevice_tokens != nil {
		edges = append(edges, user.EdgeDeviceTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePets:
		ids := make([]ent.Value, 0, len(m.removedpets))
		for id := range m.removedpets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.removedfollowers))
		for id := range m.removedfollowers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocking:
		ids := make([]ent.Value, 0, len(m.removedblocking))
		for id := range m.removedblocking {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.removedblocked_by))
		for id := range m.removedblocked_by {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDailyTasks:
		ids := make([]ent.Value, 0, len(m.removeddaily_tasks))
		for id := range m.removeddaily_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceTokens:
		ids := make([]ent.Value, 0, len(m.removeddevice_tokens))
		for id := range m.removeddevice_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, user.EdgeLikes)
	}
	if m.clearedpets {
		edges = append(edges, user.EdgePets)
	}
	if m.clearedfollowing {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.clearedfollowers {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.clearedblocking {
		edges = append(edges, user.EdgeBlocking)
	}
	if m.clearedblocked_by {
		edges = append(edges, user.EdgeBlockedBy)
	}
	if m.cleareddaily_tasks {
		edges = append(edges, user.EdgeDailyTasks)
	}
	if m.cleareddevice_tokens {
		edges = append(edges, user.EdgeDeviceTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikes:
		return m.clearedlikes
	case user.EdgePets:
		return m.clearedpets
	case user.EdgeFollowing:
		return m.clearedfollowing
	case user.EdgeFollowers:
		return m.clearedfollowers
	case user.EdgeBlocking:
		return m.clearedblocking
	case user.EdgeBlockedBy:
		return m.clearedblocked_by
	case user.EdgeDailyTasks:
		return m.cleareddaily_tasks
	case user.EdgeDeviceTokens:
		return m.cleareddevice_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikes:
		m.ResetLikes()
		return nil
	case user.EdgePets:
		m.ResetPets()
		return nil
	case user.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case user.EdgeFollowers:
		m.ResetFollowers()
		return nil
	case user.EdgeBlocking:
		m.ResetBlocking()
		return nil
	case user.EdgeBlockedBy:
		m.ResetBlockedBy()
		return nil
	case user.EdgeDailyTasks:
		m.ResetDailyTasks()
		return nil
	case user.EdgeDeviceTokens:
		m.ResetDeviceTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
